-------------------------------------------------------------------------------------------------------
INVARIANTES DE TRAGAMONEDAS
-------------------------------------------------------------------------------------------------------

--Si un jugador tiene apuestas activas, esta participando de una mesa
context Jugador
inv ApuestasActivasEntoncesParticipaEnMesa:
self.ApuestasTragamonedas->exists(a | a.estado = EstadoAp::Activa) implies not(self.participaEn = <undefined>)

--Si un jugador esta participando de una mesa, dicha mesa debe estar abierta
context Jugador
inv ParticipandoEnMesaEntoncesMesaActiva:
self.participaEn.estadoMesa = EstadoMesa::Abierta

--si una mesa esta abierta tiene un jugador participando y si esta cerrada no debe poseer ningun jugador participando
context Mesa
inv AbiertaEntoncesJugadorParticipando:
(self.estadoMesa = EstadoMesa::Abierta) implies not(self.jugadorParticipando = <undefined>) and
(self.estadoMesa = EstadoMesa::Cerrada) implies self.jugadorParticipando = <undefined>

--las apuestas activas de un jugador deben estar relacionadas con la mesa en la que esta jugando dicho jugador
context Jugador
inv ApuestasActivasEnMesaEnLaQueEstoyJugando:
self.ApuestasTragamonedas->forAll(a | a.estado = EstadoAp::Activa implies a.JugadaTragamonedas.mesaTragamonedas = self.participaEn)


--si una mesa esta cerrada no debe poseer ninguna apuesta activa
context Mesa
(self.estado = EstadoMesa::Cerrada) implies ((self.jugadaTragamonedas->forAll(j | j.apuestaTragamonedas.estado = EstadoAp::Ganada or j.apuestaTragamonedas.estado = EstadoAp::Perdida)


--todas las apuestas de un jugador corresponden a una mesa en la que participo
context Jugador
self.apuestasTragamonedas->forAll(a | self.participoEn->includes(a.jugadaTragamonedas.mesa) )

-------------------------------------------------------------------------------------------------------
INVARIANTES DE CRAPS
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------
INVARIANTES GENERALES
-------------------------------------------------------------------------------------------------------
--un jugador comun no puede tener saldo negativo a menos que sea VIP
context Jugador

inv JugadorComunNoPuedePoseerSaldoNegativo:
not(self.oclInstanceOf(JugadorVIP)) implies self.saldo >= 0

--un jugador no puede participar en mas de un juego
cantext Jugador
inv NoParticiparEnMasDeUnJuego:
not(self.participaCrapsEn = <undefined>) implies self.participaTragaEn = <undefined> and
not(self.participaTragaEn = <undefined>) implies self.participaCrapsEn = <undefined>

--un jugador no logeado no puede estar participando de un juego
context Jugador
inv NoLogeadoEntoncesNoJugando
self.estado = EstadoJugador::NoLogeado implies ( self.participaTragaEn = <undefined> and self.participaCrapsEn = <undefined> )

-------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------
OPERACIONES
-------------------------------------------------------------------------------------------------------
--

context: TipoDeJugada::calcularRetribucion(j:jugadaTragamonedas)
pre
post:	let precioFicha = j.mesaTragamonedas.valorFicha
	let cantFichas = j.apuestaTragamonedas.cantMonedas
	
	if j.res1=Fruta::Dinosaurio and j.res2=Fruta::Dinosaurio and j.res3=Fruta::Dinosaurio
	then 
		if cantFichas = 3 then return (5000 * cantFichas * precioFicha)
	if j.res1=Fruta::Dinosaurio and j.res2=Fruta::Dinosaurio and j.res3=Fruta::Dinosaurio
	then 
		if cantFichas = 2 then return (2000 * cantFichas * precioFicha)
	j.res1=Fruta::Dinosaurio and j.res2=Fruta::Dinosaurio and j.res3=Fruta::Dinosaurio
	then 
		if cantFichas = 1 then return (1000 * cantFichas * precioFicha)	

	....
	....



context: JugadaTragamonedas::pagarJugada(j:JugadaTragamonedas):void
pre:    true
post: 	let jornada = Jornada.allInstances->asSecuence->first()
	let precioFicha = j.mesaTragamonedas.valorFicha
	let cantFichas = j.apuestaTragamonedas.cantMonedas
	let jugador = j.hechaPor
	let tipoJugada = j.tipoDeJugada


	j.hechaPor.saldo = j.hechaPor.saldo@pre + calcularRetribucion(j)
	jornada.saldo = jornada.saldo@pre - calcularRetribucion(j)
	
	if tipoJugada.oclisTypeOf(Normal)
	then return
	if tipoJugada.oclisTypeOf(TodosPonen)
	then 
		j.hechaPor.saldo = calcularRetribucion(j) * 100 / oclAsType(TodosPonen).porcentaje
		oclAsType(TodosPonen).pozoFeliz.monto = oclAsType(TodosPonen).pozoFeliz.monto@pre + (calcularRetribucion(j) * 100 / oclAsType(TodosPonen).porcentaje)
	if tipoJugada.oclisTypeOf(Feliz)
		j.hechaPor.saldo = j.hechaPor.saldo@pre + oclAsType(Feliz).pozoFeliz.monto
		oclAsType(Feliz).pozoFeliz.monto = 0	

func calculo de premio comun-------
type of despues de todo el calculo-------



-------------------------------------------------------------------------------------------------------







