-------------------------------------------------------------------------------------------------------
INVARIANTES DE TRAGAMONEDAS
-------------------------------------------------------------------------------------------------------

--Si un jugador tiene apuestas activas, esta participando de una mesa
context Jugador
inv ApuestasActivasEntoncesParticipaEnMesa:
self.ApuestasTragamonedas->exists(a | a.estado = EstadoAp::Activa) implies not(self.participaEn = <undefined>)

--Si un jugador esta participando de una mesa, dicha mesa debe estar abierta
context Jugador
inv ParticipandoEnMesaEntoncesMesaActiva:
self.participaEn.estadoMesa = EstadoMesa::Abierta

--si una mesa esta abierta tiene un jugador participando y si esta cerrada no debe poseer ningun jugador participando
context Mesa
inv AbiertaEntoncesJugadorParticipando:
(self.estadoMesa = EstadoMesa::Abierta) implies not(self.jugadorParticipando = <undefined>) and
(self.estadoMesa = EstadoMesa::Cerrada) implies self.jugadorParticipando = <undefined>

--las apuestas activas de un jugador deben estar relacionadas con la mesa en la que esta jugando dicho jugador
context Jugador
inv ApuestasActivasEnMesaEnLaQueEstoyJugando:
self.ApuestasTragamonedas->forAll(a | a.estado = EstadoAp::Activa implies a.JugadaTragamonedas.mesaTragamonedas = self.participaEn)


--si una mesa esta cerrada no debe poseer ninguna apuesta activa
context Mesa
(self.estado = EstadoMesa::Cerrada) implies ((self.jugadaTragamonedas->forAll(j | j.apuestaTragamonedas.estado = EstadoAp::Ganada or j.apuestaTragamonedas.estado = EstadoAp::Perdida)


--todas las apuestas de un jugador corresponden a una mesa en la que participo
context Jugador
self.apuestasTragamonedas->forAll(a | self.participoEn->includes(a.jugadaTragamonedas.mesa) )

-------------------------------------------------------------------------------------------------------
INVARIANTES DE CRAPS
-------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------
INVARIANTES GENERALES
-------------------------------------------------------------------------------------------------------
--un jugador comun no puede tener saldo negativo a menos que sea VIP
context Jugador

inv JugadorComunNoPuedePoseerSaldoNegativo:
not(self.oclInstanceOf(JugadorVIP)) implies self.saldo >= 0

--un jugador no puede participar en mas de un juego
cantext Jugador
inv NoParticiparEnMasDeUnJuego:
not(self.participaCrapsEn = <undefined>) implies self.participaTragaEn = <undefined> and
not(self.participaTragaEn = <undefined>) implies self.participaCrapsEn = <undefined>

--un jugador no logeado no puede estar participando de un juego
context Jugador
inv NoLogeadoEntoncesNoJugando
self.estado = EstadoJugador::NoLogeado implies ( self.participaTragaEn = <undefined> and self.participaCrapsEn = <undefined> )

-------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------
OPERACIONES
-------------------------------------------------------------------------------------------------------
--

context: TipoDeJugada::calcularRetribucion(j:jugadaTragamonedas)
pre
post:	let precioFicha = j.mesaTragamonedas.valorFicha
	let cantFichas = j.apuestaTragamonedas.cantMonedas
	
	if j.res1=Fruta::Dinosaurio and j.res2=Fruta::Dinosaurio and j.res3=Fruta::Dinosaurio
	then 
		if cantFichas = 3 then return (5000 * cantFichas * precioFicha)
	if j.res1=Fruta::Dinosaurio and j.res2=Fruta::Dinosaurio and j.res3=Fruta::Dinosaurio
	then 
		if cantFichas = 2 then return (2000 * cantFichas * precioFicha)
	j.res1=Fruta::Dinosaurio and j.res2=Fruta::Dinosaurio and j.res3=Fruta::Dinosaurio
	then 
		if cantFichas = 1 then return (1000 * cantFichas * precioFicha)	

	....
	....




	
	
	if tipoJugada.oclisTypeOf(Normal)
	then return
	if tipoJugada.oclisTypeOf(TodosPonen)
	then 
		j.hechaPor.saldo = calcularRetribucion(j) * 100 / oclAsType(TodosPonen).porcentaje
		oclAsType(TodosPonen).pozoFeliz.monto = oclAsType(TodosPonen).pozoFeliz.monto@pre + (calcularRetribucion(j) * 100 / oclAsType(TodosPonen).porcentaje)
	if tipoJugada.oclisTypeOf(Feliz)
		j.hechaPor.saldo = j.hechaPor.saldo@pre + oclAsType(Feliz).pozoFeliz.monto
		oclAsType(Feliz).pozoFeliz.monto = 0	

func calculo de premio comun-------
type of despues de todo el calculo-------



-------------------------------------------------------------------------------------------------------




context: JugadaTragamonedas::pagarJugada(j:JugadaTragamonedas):void
pre:    true
post: 	let jornada = Jornada.allInstances->asSecuence->first()
	let precioFicha = j.mesaTragamonedas.valorFicha
	let cantFichas = j.apuestaTragamonedas.cantMonedas
	let jugador = j.hechaPor
	let tipoJugada = j.tipoDeJugada
	
	j.hechaPor.saldo = j.hechaPor.saldo@pre + cualEsElPrepmio(j)
	jornada.saldo = jornada.saldo@pre - cualEsElPrepmio(j)




--esta operacion calcula cual es el premio correspondiente a una jugada de tragamonedas.
--ya tiene en cuenta el premio gordo progresivo de las tragamonedas
cualEsElPrepmio(j:JugadaTagamonesas):Numero
pre:	true
post:	let conjRes:Collection  = select(	r | 	r.res1 = j.res1 and
						r.res2 = j.res2 and
						r.res3 = j.res2 and
						r.cantMonedas = j.apuestaTragamonesas.cantMonedas) 

	if not(conjRes->isEmpty()) then
		if 	j.res1 = Fruta::Dinosaurio and
			j.res2 = Fruta::Dinosaurio and
			j.res3 = Fruta::Dinosaurio and
			j.mesaTragamonedas.CantPalancasMax = 3
		then
			result = conjRes->asSecuence()->first().ganMonedas + j.mesaTragamonedas.pozoProgresivo.monto
		else
			result = conjRes->asSecuence()->first().ganMonedas
		endif
	else
		result = 0

	endif 




--------------------
--------------------

context: pagarJugadaTraga(j:JugadaTragamonedas):void
pre:    true
post: 	
	-- pago resultado jugada y pago pozo progresivo y resiteo pozo progresivo
	pagarJugadaTragaBasica(j)
	-- cobro porcentaje jugada todos ponen
	cobrarJugadaToposPonen(j)
	-- pago jugada feliz y reseteo pozo feliz
	pagarJugadaFeliz(j)

	


-- si la jugada es todos ponen decremento saldo jugador e incremento pozo feliz
pagarJugadaFeliz(j:JugadaTragamonedas):void
pre:    true -- no pagada
post:	let tipoJugada = j.tipoDeJugada

	if tipoJugada.oclisTypeOf(Feliz)
		j.hechaPor.saldo = j.hechaPor.saldo@pre + oclAsType(Feliz).pozoFeliz.monto
		oclAsType(Feliz).pozoFeliz.monto = 0
	endif


-- si la jugada es todos ponen decremento saldo jugador e incremento pozo feliz
cobrarJugadaToposPonen(j:JugadaTragamonedas):void
pre:    true -- no pagada
post:	let tipoJugada = j.tipoDeJugada

	if tipoJugada.oclisTypeOf(TodosPonen)
	then 
		j.hechaPor.saldo = 

			j.hechaPor.saldo@pre +
			(damePremioTraga(j) + damePremioProgesivo(j)) * 100 / oclAsType(TodosPonen).porcentaje
		
		oclAsType(TodosPonen).pozoFeliz.monto = 

			oclAsType(TodosPonen).pozoFeliz.monto@pre + 
			((damePremioTraga(j) + damePremioProgesivo(j)) * 100 / oclAsType(TodosPonen).porcentaje)
	endif



-- incremento saldo jugados de jugada y pozo progresivo (si corresponde)
-- decremento saldo casino
-- decremento pozo (si corresponde)
pagarJugadaTragaBasica(j:JugadaTragamonedas):void
pre:    true -- no pagada
post:	
	let jornada = Jornada.allInstances->asSecuence->first()

	j.hechaPor.saldo = j.hechaPor.saldo@pre + (damePremioTraga(j) + damePremioProgesivo(j))
	jornada.saldo = jornada.saldo@pre - cualEsElPrepmio(j)
	if damePremioProgesivo(j) <> 0
	then
		PozoProgresivo.allInstances()->asSecuence()->first().monto = 0
	endif


-- devuelve el valor del premio correspondiente a la jugada
damePremioTraga(j:JugadaTagamonesas):Numero
pre:	
post:	let conjRes:Collection  = select(	r | 	r.res1 = j.res1 and
						r.res2 = j.res2 and
						r.res3 = j.res2 and
						r.cantMonedas = j.apuestaTragamonesas.cantMonedas) 
	let precioFicha = j.mesaTragamonedas.valorFicha

	if not(conjRes->isEmpty()) then
		result = conjRes->asSecuence()->first().ganMonedas * precioFicha 
	else
		result = 0

	endif 


-- devuelve el valor del premio progresivo correspondiente a la jugada
damePremioProgesivo(j:JugadaTagamonesas):Numero
pre:	true
post:	let conjRes:Collection  = select(	r | 	r.res1 = j.res1 and
						r.res2 = j.res2 and
						r.res3 = j.res2 and
						r.cantMonedas = j.apuestaTragamonesas.cantMonedas) 
	let precioFicha = j.mesaTragamonedas.valorFicha

	if not(conjRes->isEmpty()) then
		if 	j.res1 = Fruta::Dinosaurio and
			j.res2 = Fruta::Dinosaurio and
			j.res3 = Fruta::Dinosaurio and
			j.mesaTragamonedas.CantPalancasMax = 3
		then
			result = j.mesaTragamonedas.pozoProgresivo.monto * precioFicha 
		else
			result = 0
		endif
	else
		result = 0
	endif 



		









